{"version":3,"file":"lib_index_js.692940fcb9a6b62f4076.js","mappings":"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","sources":["webpack://jupyterlab-mdx/./src/index.ts","webpack://jupyterlab-mdx/./src/xr.ts"],"sourcesContent":["import { JupyterFrontEnd, JupyterFrontEndPlugin } from '@jupyterlab/application';\nimport { INotebookTracker } from '@jupyterlab/notebook';\nimport { MarkdownCell } from '@jupyterlab/cells';\nimport { processAll } from './xr';  // Your main label processing logic\nimport { Cell } from '@jupyterlab/cells';\n\nconst plugin: JupyterFrontEndPlugin<void> = {\n  id: 'jupyterlab-mdx',\n  autoStart: true,\n  requires: [INotebookTracker],\n  activate: (app: JupyterFrontEnd, tracker: INotebookTracker) => {\n    console.log('JupyterLab extension jupyterlab-mdx is activated!');\n\n    const wireCell = (cell: any) => {\n      if (cell.model?.type !== 'markdown' || cell._mdxWired) return;\n      cell._mdxWired = true;\n\n      // Only call processAll after user-initiated rendering\n      cell.renderedChanged.connect(() => {\n        if ((cell as MarkdownCell).rendered) {\n          console.log(\"jupyterlab-mdx: Cell re-rendered → processAll()\");\n          processAll(tracker);\n        }\n      });\n    };\n\n    const hookNotebook = (panel: any) => {\n      console.log(\"jupyterlab-mdx: Notebook widget added\");\n\n      panel.content.widgets.forEach(wireCell);\n      panel.content.model?.cells.changed.connect(() => {\n        panel.content.widgets.forEach(wireCell);\n      });\n\n      // Wait until all markdown cells are rendered before processing\n      const promises = panel.content.widgets.map((cell: Cell) => {\n        wireCell(cell);\n        if (cell.model?.type !== 'markdown') return Promise.resolve();\n\n        const mdCell = cell as MarkdownCell;\n        return mdCell.rendered\n          ? Promise.resolve()\n          : new Promise<void>(resolve => {\n              const onRendered = () => {\n                mdCell.renderedChanged.disconnect(onRendered);\n                resolve();\n              };\n              mdCell.renderedChanged.connect(onRendered);\n            });\n      });\n\n      Promise.all(promises).then(() => {\n        console.log(\"jupyterlab-mdx: All markdown cells rendered. Delaying to run processAll.\");\n        // HACK.  I need to find a better way to handle this.   Even though\n        // this doesn't happen until all the promises have completed, there\n        // is still a race condition if I call processAll immediately\n        // wherein the DOM has not yet populated when processAll\n        // is called and thus there are no text nodes to update markdown\n        // so I wait a bit.  Arggg....\n        setTimeout(() => {\n          console.log(\"jupyterlab-mdx: Delayed processAll running now\");\n          processAll(tracker);\n        }, 100); // You can increase to 50–100 ms if needed\n      });\n    };\n\n    // Wire up already open notebook\n    if (tracker.currentWidget) {\n      hookNotebook(tracker.currentWidget);\n    }\n\n    // Wire up future notebooks\n    tracker.widgetAdded.connect((_, panel) => {\n      hookNotebook(panel);\n    });\n  }\n};\n\nexport default plugin;\n","// xr.ts (inside src/ directory of your extension)\n\nimport { INotebookTracker } from '@jupyterlab/notebook';\nimport {\n  MarkdownCell,\n  isMarkdownCellModel\n} from '@jupyterlab/cells';\n\n\n// A label comes in one of two forms.   It is either a member of the global\n// enumeration or it is a membr of a named enumeration.   If it has the form\n// @foo then it is the member \"foo\" of the global enumeration.   If it has the form\n// @bar:foo then it is the member \"foo\" of the named enumeration with name \"bar\".\nconst labelMap = new Map<string, { name: string | null; id: string; n: number }>();\nconst enumCounters = new Map<string, number>();\n\n// TAGGABLE is a reference to the \\tag command in LaTex.  It is used to\n// number equations.  Currently only do this for the 'eq' but we may\n// add other predefined namespaces.\nconst TAGGABLE_NAMES = new Set(['eq']);\n\nconsole.log(\"Loaded xr.ts module\");\n\n/**\n * Converts an optional enumeration name and ID to a fully qualified key.\n * @param name - The enumeration name (e.g. \"eq\", \"fig\"), or null for global.\n * @param id - The specific label ID.\n * @returns A composite string key like \"eq:foo\" or \"foo\".\n */\nfunction toId(name: string | null, id: string): string {\n  return name ? `${name}:${id}` : id;\n}\n\nfunction formatLabel(name: string | null, n: number | string, raw = false): string {\n  if (name && TAGGABLE_NAMES.has(name.toLowerCase())) {\n    return raw ? `${n}` : `(${n})`;\n  }\n  return raw ? `${n}` : name ? `${name} ${n}` : `${n}`;\n}\n\n/**\n * Walks the DOM looking for TEXT_NODEs and finding labels.\n * It increment and then assigns an integer to each label thereby\n * creating an enumeration.\n *\n * It also supports named enumerations.\n */\nexport function scanLabels(tracker: INotebookTracker): void {\n\n  labelMap.clear();\n  enumCounters.clear();\n  let count : number = 0;\n\n  console.log(\"scanLabels\");\n\n  // walk every Markdown cell\n  for (const cell of tracker.currentWidget?.content.widgets ?? []) {\n    if (!(cell instanceof MarkdownCell)) {\n      continue;\n    }\n\n    // narrow the model to IMarkdownCellModel so TS knows about .value\n    const model = cell.model;\n    if (!isMarkdownCellModel(model)) {\n      // if for some reason it isn’t, move on.\n      continue;\n    }\n    const text = model.sharedModel.getSource();\n\n    count++;\n    console.log(\"scanLabels markdown node \" + count + \" text: \" + text);\n    const re = /@([A-Za-z]+:)?([A-Za-z0-9:_\\-]+)/g;\n    let m;\n    while ((m = re.exec(text)) !== null) {\n      const enumName = m[1];\n      const id = m[2];\n      const name = enumName ? enumName.slice(0, -1) : null;\n      const key = toId(name, id);\n      if (!labelMap.has(key)) {\n        const counterKey = name ?? '_global';\n        const n = (enumCounters.get(counterKey) ?? 0) + 1;\n        enumCounters.set(counterKey, n);\n        labelMap.set(key, { name, id, n });\n      }\n    }\n  }\n}\n\n\nfunction rewriteText(textNode: Text): void {\n  const re = /(@|#)([A-Za-z]+:)?([A-Za-z0-9:_\\-]+)(!?)/g;\n  const data = textNode.data;\n  const frag = document.createDocumentFragment();\n  let last = 0, m;\n\n  while ((m = re.exec(data)) !== null) {\n    const [full, sym, enumName, id, bang] = m;\n    const name = enumName ? enumName.slice(0, -1) : null;\n    const key = toId(name, id);\n    const entry = labelMap.get(key);\n\n    frag.appendChild(document.createTextNode(data.slice(last, m.index)));\n    last = m.index + full.length;\n\n    if (sym === '@') {\n      const n = entry?.n ?? '??';\n      const span = document.createElement('span');\n      span.innerHTML = `<a id=\"${toId(name, id)}\">${n}</a>` +\n        `<span style=\"display:none\">\\\\label{${toId(name, id)}}</span>`;\n      frag.appendChild(span);\n    }\n\n    if (sym === '#') {\n      const n = entry?.n ?? '??';\n      const label = formatLabel(entry?.name ?? name, n, bang === '!');\n      const a = document.createElement('a');\n      a.href = `#${toId(entry?.name ?? name, id)}`;\n      a.textContent = label;\n      frag.appendChild(a);\n    }\n  }\n\n  frag.appendChild(document.createTextNode(data.slice(last)));\n  textNode.parentNode?.replaceChild(frag, textNode);\n}\n\nfunction walk(node: Node): void {\n  // recurisively finds the text nodes and calls rewriteText on them.\n  if (node.nodeType === Node.TEXT_NODE) {\n    rewriteText(node as Text);\n  } else {\n    node.childNodes.forEach(walk);\n  }\n}\n\nexport function rewriteAll(): void {\n\n  // For jupyter classic, .text_cell_render refers to cells that are\n  // <div class=\"text_cell_render\">.  The div contains the renereded\n  // HTML.\n  //\n  // jupyter lab. renders the markdown to a\n  // <div class=\"jp-RenderedHTMLCommon jp-RenderedMarkdown\">\n  \n  document.querySelectorAll('.text_cell_render, .jp-RenderedHTMLCommon').forEach(walk);\n\n  if ((window as any).MathJax?.typesetPromise) { // MathJax v3.\n    (window as any).MathJax.typesetPromise();\n  } else if ((window as any).MathJax?.Hub?.Queue) {  // MathJax v2.\n    (window as any).MathJax.Hub.Queue(['Typeset', (window as any).MathJax.Hub]);\n  }\n}\n\nlet isProcessing = false;\n\nexport function processAll(tracker: INotebookTracker): void {\n  console.log(\"processAll isProcessing=\" + isProcessing);\n  if (isProcessing) return;  // Prevent recursion\n\n  isProcessing = true;\n  try {\n    scanLabels(tracker);\n    rewriteAll();\n  } finally {\n    isProcessing = false;  // Ensure flag is cleared even if an error occurs\n  }\n}\n\n\nexport {\n  labelMap,\n  enumCounters,\n  toId,\n  formatLabel\n};"],"names":[],"sourceRoot":""}